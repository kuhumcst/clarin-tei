{"version":3,"sources":["dk/cst/pedestal/sp/auth.cljc"],"mappings":";AASA;;;wCAAA,xCAAMA,wFAEHC,EAAEC;AAFL,AAGE,wDAAA,hDAAM,AAACC,gBAAM,AAACC,kBAAUH,EAAEC;;AAE5B,iDAAA,jDAAMG,0GACHC;AADH,AAEE,8DAAA,mFAAA,2DAAA,oDAAA,zPAACC,+CAAOD;;AAEV;;;;;;;;;kDAAA,lDAAME,4GAQHC;AARH,AASE,GACE,sBAAAE,rBAAUF;AAAW,IAAAG,WAAMH;IAANG,eAAA,EAAA,CAAAA,oBAAAD,oBAAA,AAAAC,aAAA;AAAA,AAAA,QAAAA;KAAA;AACiBE;;;KADjB;AAEO,4BAAA,rBAACC;;;KAFR;AAGQ,4BAAA,rBAACA;;;;AAHT,MAAA,KAAAF,MAAA,CAAA,mEAAAD;;;;AADvB,GAKE,AAACI,qBAAKP;AALR,kBAAAC;AAAA,AAKoB,uDAAAA,hDAACV,sCAAQS;;;AAL7B,GAME,AAACQ,oBAAIR;AAAWA;;AANlB;;;;;AAQF;;;;;;wCAAA,xCAAMS,wFAKHC;AALH,AAME,OAACX,gDAAqB,AAAA,6FAAYW","names":["dk.cst.pedestal.sp.auth/submap?","m","parent","cljs.core/first","clojure.data/diff","dk.cst.pedestal.sp.auth/request->assertions","request","cljs.core.get_in","dk.cst.pedestal.sp.auth/condition->auth-test","condition","p1__39345#","cljs.core/Keyword","G__39348","js/Error","cljs.core/some?","cljs.core/constantly","cljs.core/map?","cljs.core/fn?","dk.cst.pedestal.sp.auth/auth-override","assertions"],"sourcesContent":["(ns dk.cst.pedestal.sp.auth\n  \"Create inline authorisation logic using SAML assertions. The `if-permit` and\n  `only-permit` macros can be used from both Clojure and ClojureScript.\n\n  For route-level authorisation + ahead-of-time checks from within interceptors,\n  use the `permit-request?` function from `dk.cst.pedestal.sp.interceptors`.\"\n  (:require [clojure.data :as data])\n  #?(:cljs (:require-macros [dk.cst.pedestal.sp.auth])))\n\n(defn submap?\n  \"Is `m` a submap of `parent`?\"\n  [m parent]\n  (nil? (first (data/diff m parent))))\n\n(defn request->assertions\n  [request]\n  (get-in request [:session :saml :assertions]))\n\n(defn condition->auth-test\n  \"Return a function to test an assertions map based on a given `condition`:\n\n    :authenticated - requires authentication to access.\n              :all - can be accessed by anyone, no restrictions apply.\n             :none - no access by anyone under any circumstances.\n               map - allow access when the assertions contain this submap.\n                fn - takes assertions as input and returns true if accessible.\"\n  [condition]\n  (cond\n    (keyword? condition) (case condition\n                           :authenticated some?\n                           :all (constantly true)\n                           :none (constantly false))\n    (map? condition) #(submap? condition %)\n    (fn? condition) condition))\n\n(defn auth-override\n  \"Create an auth test override from the `assertions` map.\n\n  During development, the assertions map may contain a :condition key defining\n  an alternative test used to override the conditions of a production system.\"\n  [assertions]\n  (condition->auth-test (:condition assertions)))\n\n(defmacro if-permit\n  \"Checks that `assertions` satisfies `condition`. When true, returns the\n  first clause of `body`; else returns the second clause.\"\n  [[assertions condition] & body]\n  `(if ((or (auth-override ~assertions)\n            (condition->auth-test ~condition)) ~assertions)\n     ~@body))\n\n(defmacro only-permit\n  \"Checks that `assertions` satisfies `condition`. If true, returns `body`;\n  else throws an exception.\"\n  [[assertions condition] & body]\n  `(if ((or (auth-override ~assertions)\n            (condition->auth-test ~condition)) ~assertions)\n     (do ~@body)\n     (throw (ex-info \"Unsatisfied condition\" {::condition ~condition}))))\n\n#?(:clj\n   (defn enforce-condition\n     \"Fail fast if the `request` assertions do not meet a `condition`.\"\n     [request condition]\n     (only-permit [(request->assertions request) condition])))\n"]}