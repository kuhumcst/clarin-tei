{"version":3,"sources":["dk/cst/cuphic/zip.cljc"],"mappings":";AAIA;;;mCAAA,nCAAMA,8EAEHC;AAFH,AAGE,OAACC,mBAAW,AAACC,gDAAQC,wBACA,AAACC,mDAAWC,qBAAK,AAACC,qBAAWC,2BACtCC,cACA,WAAKC,KAAKC;AAAV,AACE,GAAI,AAACP,wBAAQM;AACX,OAACE,oBAAU,6CAAA,7CAACC,8EAAQF,UAAU,AAACG,eAAKJ;;AACpC,OAACE,oBAAU,6CAAA,7CAACC,gFAAQF,UAAU,AAACG,eAAKJ;;GACxCT;;AAEd;;;mCAAA,nCAAMc,8EAEHC;AAFH,AAGE,OAACC,mDAAW,AAACV,qBAAWW,wBAAU,AAACC,kBAAQC,iBAASJ;;AAEtD;;;;kCAAA,lCAAMK,4EAGHC,EAAEN;AAHL,AAIE,IAAAO,WAAsBP;IAAtBQ,aAAAD;WAAA,AAAAE,4CAAAD,WAAA,IAAA,lEAAQd;cAARc,VAAiBR;AAAjB,AAAA,IAAAO,eAAAA;;AAAA,AAAA,IAAAG,aAAAH;eAAA,AAAAE,4CAAAC,WAAA,IAAA,tEAAQhB;cAARgB,VAAiBV;AAAjB,AACE,GAAI,AAACE,uBAASF;AACZ,OAACW,iBAASX;;AACV,eAAO,AAACI,iBAAS,CAACE,kCAAAA,oDAAAA,pBAAEN,gCAAAA,xBAAIN,gCAAAA;;;;;;;AAG9B;;;iCAAA,yCAAAkB,1EAAME;;AAAN,AAAA,IAAAD,aAAAD;WAAA,AAAAH,4CAAAI,WAAA,IAAA,lEAEInB;QAFJ,AAAAe,4CAAAI,WAAA,IAAA,/DAESE;UAFTF,NAEeb;AAFf,AAGE,GACE,AAACE,uBAASF;AAAKA;;AADjB,oBAEE,AAACgB,kBAAUhB;AAAK,OAACgB,kBAAUhB;;AAF7B,oBAGE,AAACiB,eAAOjB;AAAK,eAAO,AAACiB,eAAOjB;;;;AAH9B,AAIQ,yDAAA,IAAA,tDAACkB,8CAAMlB;;;;;;;;AAEjB;;;kCAAA,8CAAAmB,hFAAMM,4EAEHzB;AAFH,AAAA,IAAAoB,aAAAD;IAAAE,aAAA,AAAA5B,cAAA2B;IAAAE,eAAA,AAAAC,gBAAAF;IAAAA,iBAAA,AAAAG,eAAAH;WAAAC,PAEQ5B;YAFR2B,RAEeK;AAFf,AAGE,OAACC,+CAAOC,yBAAiB,AAACC,oBAAY7B,IAAIN,MAAM,AAACoC,kBAAQJ","names":["dk.cst.cuphic.zip/vector-map-zip","root","clojure.zip/zipper","cljs.core.some_fn","cljs.core/vector?","cljs.core.every_pred","cljs.core/map?","cljs.core/complement","cljs.core/record?","cljs.core/seq","node","children","cljs.core/with-meta","cljs.core.into","cljs.core/meta","dk.cst.cuphic.zip/iterate-zipper","loc","cljs.core.take_while","clojure.zip/end?","cljs.core/iterate","clojure.zip/next","dk.cst.cuphic.zip/reduce-zipper","f","G__44727","vec__44728","cljs.core.nth","vec__44736","clojure.zip/root","p__44745","vec__44752","dk.cst.cuphic.zip/skip-subtree","_","clojure.zip/right","clojure.zip/up","cljs.core.assoc","p__44768","vec__44770","seq__44771","first__44772","cljs.core/first","cljs.core/next","dk.cst.cuphic.zip/multi-replace","nodes","cljs.core.reduce","clojure.zip/insert-right","clojure.zip/replace","cljs.core/reverse"],"sourcesContent":["(ns dk.cst.cuphic.zip\n  \"Generic zipper functions.\"\n  (:require [clojure.zip :as zip]))\n\n(defn vector-map-zip\n  \"Also zips maps in addition to zipping vectors. Intentionally skips records.\"\n  [root]\n  (zip/zipper (some-fn vector?                              ; branch?\n                       (every-pred map? (complement record?)))\n              seq                                           ; children\n              (fn [node children]                           ; make-node\n                (if (vector? node)\n                  (with-meta (into [] children) (meta node))\n                  (with-meta (into {} children) (meta node))))\n              root))\n\n(defn iterate-zipper\n  \"Lazily iterate through all zipper states from the given `loc` to the end.\"\n  [loc]\n  (take-while (complement zip/end?) (iterate zip/next loc)))\n\n(defn reduce-zipper\n  \"Traverse the zipper starting from `loc`, applying `f` to all locs on the way.\n  Once the whole zipper has been traversed, zip up and return the changed tree.\"\n  [f loc]\n  (loop [[node :as loc] loc]\n    (if (zip/end? loc)\n      (zip/root loc)\n      (recur (zip/next (f loc node))))))\n\n;; https://groups.google.com/d/msg/clojure/FIJ5Pe-3PFM/JpYDQ2ejBgAJ\n(defn skip-subtree\n  \"Fast-forward a zipper to skip the subtree at `loc`.\"\n  [[node _ :as loc]]\n  (cond\n    (zip/end? loc) loc\n    (zip/right loc) (zip/right loc)\n    (zip/up loc) (recur (zip/up loc))\n    :else (assoc loc 1 :end)))\n\n(defn multi-replace\n  \"Replace `loc` with `nodes`.\"\n  [loc [node & nodes]]\n  (reduce zip/insert-right (zip/replace loc node) (reverse nodes)))\n"]}