{"version":3,"sources":["dk/cst/stucco/dom/drag.cljs"],"mappings":";AAWA;;;;;;AAAKA,mCAKH,6CAAA,7CAACC;AAEH;;;;uCAAA,vCAAMC,sFAGHC,QAAQC;AAHX,AAIE,kBAAKC;AAAL,AACE,IAAMC,UAAS,4CAAK,AAACC,eAAKJ;IACpBK,KAAS,AAAgBH;IACzBI,UAAS,AAAUJ;IACnBK,WAAS,uBAAA,tBAAG,AAAeD;IAC3BE,WAAS,wBAAA,vBAAG,AAAgBF;IAC5BG,QAAS,kBAAA,lBAAYH;AAL3B,AAOE,4GAAA,2CAAA,mEAAA,yEAAA,nSAACI,mDAAMb,iCAAUc,gBAAMR,8GAAoBH,uEACAC,kEACAQ;;AAC3C,WAAA,XAAUJ,qBAAaF;;AAGvB,oBAAA,nBAAM,AAAiBE;;AACvB,iBAAA,hBAAM,AAAcA;;AAGpB,oBAAA,pBAAM,AAAaI;;AACnB,mBAAA,cAAA,jCAAeA;;AACf,AAACG,0BAA6BH;;AAC9B,AAAeJ,gBAAGI,MAAMF,SAASC;;AAOjC,OAACK,WACC;AAAA,AACE,4DAAA,5DAACC,yCAAkB,AAAcR;;AACjC,wDAAA,jDAACQ,yCAAkBR;GAHvB;;;AAMN;;;;iCAAA,jCAAMS,0EAGHC;AAHH,AAIE,kBAAKd;AAAL,AACE,AAAiBA;;AACjB,qDAAA,rDAACe,4CAAqB,AAAUf;;AAChC,IAAMmB,SAAQ,AAAUnB;IAClBC,UAAQ,uBAAA,vBAAU,AAAgBD;IADxCgB,aAEwC,4CAAA,AAAAI,5CAACF,4DAAKvB,kCAAUM;IAFxDe,iBAAA,AAAAC,4BAAAD;cAAA,AAAAE,4CAAAF,eAAA,rEAEclB;gBAFd,AAAAoB,4CAAAF,eAAA,vEAEsBjB;YAFtB,AAAAmB,4CAAAF,eAAA,nEAEgCT;IAC1Bc,SAAQ,AAACC,wBAA2BvB;AAH1C,AAME,oBAAMD;AAAN,AACE,AAACU,mDAAMb,iCAAU4B,iBAAOtB;;AACxB,AAAc,AAAcM,6BAAOA;;AAMnC,GAAM,AAACiB,cAAI,iBAAAC,oBAAKJ;AAAL,AAAA,oBAAAI;AAAY,OAAWJ,gBAAOF;;AAA9BM;;;AAAX,AACE,IAAAC,WAAS,CAAC5B,wCAAAA,0CAAAA;AAAV,AAAA,sFAAA4B,8BAAAA,5GAACZ,wCAAAA,kDAAAA;;AADH;;;AARF;;;;AAYN,AAAKa,sCACH,8CAAK3B;AAAL,AACE,AAAiBA;;AACjB,oCAAA,5BAAM,AAAA,AAAAA;;AAGV,AAAK4B,uCACH,+CAAK5B;AAAL,AACE,AAAiBA;;AACjB,yDAAA,lDAACY,yCAAkB,AAAUZ;;AAEjC,AAAK6B,uCACH,+CAAK7B;AAAL,AACE,AAAiBA;;AACjB,4DAAA,rDAACe,4CAAqB,AAAUf;;AAGpC,AAAK8B,qCACH,6CAAK9B;AAAL,AACE,gEAAA,hEAACe,4CAAqB,AAAc,AAAUf;;AAC9C,4DAAA,rDAACe,4CAAqB,AAAUf","names":["dk.cst.stucco.dom.drag/drag-data","cljs.core.atom","dk.cst.stucco.dom.drag/on-drag-start","drag-fn","source-id","e","drag-id","cljs.core/hash","dt","element","x-offset","y-offset","ghost","cljs.core.swap_BANG_","cljs.core/assoc","js/document.body.appendChild","js/setTimeout","dk.cst.stucco.dom.bem/add-modifier!","dk.cst.stucco.dom.drag/on-drop","drop-fn","dk.cst.stucco.dom.bem/remove-modifier!","map__39703","cljs.core/--destructure-map","cljs.core.get","target","cljs.core/deref","source","js/document.getElementById","cljs.core/dissoc","cljs.core/not","and__5043__auto__","G__39705","dk.cst.stucco.dom.drag/on-drag-over","dk.cst.stucco.dom.drag/on-drag-enter","dk.cst.stucco.dom.drag/on-drag-leave","dk.cst.stucco.dom.drag/on-drag-end"],"sourcesContent":["(ns dk.cst.stucco.dom.drag\n  \"A functional take on drag-and-drop.\n\n  All successful drops execute the code `(drop-fn (drag-fn))` in order\n  to effectuate the necessary state changes. Certain functions are merely\n  required to satisfy the HTML drag-and-drop API. Such functions have been\n  def'ed rather than defn'ed to mark their special status.\"\n  (:require [dk.cst.stucco.dom.bem :as bem]))\n\n;; TODO: safari does not display drag image, fix!\n\n(def drag-data\n  \"Temporary storage for drag data.\n\n  This circumvents the string restriction of the JavaScript dataTransfer object,\n  allowing this API to store any temporary data, e.g. functions, when dragging.\"\n  (atom {}))\n\n(defn on-drag-start\n  \"The `drag-fn` is called with no args on a successful drop. The container's\n  `source-id` is needed to check for a illegal drop states when dropping.\"\n  [drag-fn source-id]\n  (fn [e]\n    (let [drag-id  (str (hash drag-fn))\n          dt       (.-dataTransfer e)\n          element  (.-target e)\n          x-offset (/ (.-offsetWidth element) 2)\n          y-offset (/ (.-offsetHeight element) 2)\n          ghost    (.cloneNode element true)]\n      ;; Store temporary data in the drag-data atom keyed to the `drag-id`.\n      (swap! drag-data assoc drag-id {:drag-fn   drag-fn\n                                      :source-id source-id\n                                      :ghost     ghost})\n      (.setData dt \"drag-id\" drag-id)\n\n      ;; TODO: what about other effects, i.e. copy?\n      (set! (.-effectAllowed dt) \"move\")\n      (set! (.-dropEffect dt) \"move\")\n\n      ;; The ghost is so we can differentiate source and the drag image styling.\n      (.add (.-classList ghost) \"--ghost\")\n      (.setAttribute ghost \"aria-hidden\" \"true\")\n      (js/document.body.appendChild ghost)\n      (.setDragImage dt ghost x-offset y-offset)\n\n      ;; Modifying a dragged element after an onDragStart event will glitch both\n      ;; Chrome and Safari, making this slight delay necessary. Firefox is OK.\n      ;; The drag-parent modifier class is also necessary to disable :hover\n      ;; effects. Chrome seems to otherwise temporarily remove the DOM element,\n      ;; triggering :hover on the element to the right.\n      (js/setTimeout\n        (fn []\n          (bem/add-modifier! (.-parentNode element) \"drag-parent\")\n          (bem/add-modifier! element \"drag\"))\n        100))))\n\n(defn on-drop\n  \"The `drop-fn` is called with the drag-fn's output as its input on a\n  successful drop.\"\n  [drop-fn]\n  (fn [e]\n    (.preventDefault e)\n    (bem/remove-modifier! (.-target e) \"drag-over\")\n    (let [target  (.-target e)\n          drag-id (.getData (.-dataTransfer e) \"drag-id\")\n          {:keys [drag-fn source-id ghost]} (get @drag-data drag-id)\n          source  (js/document.getElementById source-id)]\n\n      ;; If a drag exists, remove traces of it no matter if the drop executes.\n      (when drag-fn\n        (swap! drag-data dissoc drag-id)\n        (.removeChild (.-parentNode ghost) ghost)\n\n        ;; Only execute the drop when the source does not CONTAIN the dropzone!\n        ;; If executed regardless, the data would vanish since the source that\n        ;; contains the child that the data is being transferred to would then\n        ;; be removed from the underlying collection and therefore from the DOM.\n        (when (not (and source (.contains source target)))\n          (drop-fn (drag-fn)))))))\n\n;; The onDragOver handler is needed for drag-and-drop to work.\n(def on-drag-over\n  (fn [e]\n    (.preventDefault e)\n    (set! e.dataTransfer.dropEffect \"move\")))\n\n;; TODO: check for illegal drop and display forbidden cursor?\n(def on-drag-enter\n  (fn [e]\n    (.preventDefault e)\n    (bem/add-modifier! (.-target e) \"drag-over\")))\n\n(def on-drag-leave\n  (fn [e]\n    (.preventDefault e)\n    (bem/remove-modifier! (.-target e) \"drag-over\")))\n\n;; TODO: does not fire when the drag is internal - fix!\n(def on-drag-end\n  (fn [e]\n    (bem/remove-modifier! (.-parentNode (.-target e)) \"drag-parent\")\n    (bem/remove-modifier! (.-target e) \"drag\")))\n"]}